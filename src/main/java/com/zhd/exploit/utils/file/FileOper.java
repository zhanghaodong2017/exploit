package com.zhd.exploit.utils.file;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;

import org.apache.tools.zip.ZipEntry;
import org.apache.tools.zip.ZipFile;
import org.apache.tools.zip.ZipOutputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileOper {
	private static Logger logger = LoggerFactory.getLogger(FileOper.class);

	/**
	 * 读取txt文件按行返回
	 * 
	 * @return
	 */
	public static List<String> readLinesByFile(File sourcefile) {
		FileReader reader = null;
		BufferedReader br = null;
		List<String> lines = new ArrayList<String>();
		try {
			reader = new FileReader(sourcefile);
			br = new BufferedReader(reader);
			String str = null;
			while ((str = br.readLine()) != null) {
				lines.add(str);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			close(br);
			close(reader);
		}
		return lines;
	}

	public static void copyFile(File sourcefile, File targetFile) {
		// 新建文件输入流并对它进行缓冲
		FileInputStream input = null;
		BufferedInputStream inbuff = null;
		// 新建文件输出流并对它进行缓冲
		FileOutputStream out = null;
		BufferedOutputStream outbuff = null;
		try {
			input = new FileInputStream(sourcefile);
			inbuff = new BufferedInputStream(input);
			out = new FileOutputStream(targetFile);
			outbuff = new BufferedOutputStream(out);

			// 缓冲数组
			byte[] b = new byte[1024 * 5];
			int len = 0;
			while ((len = inbuff.read(b)) != -1) {
				outbuff.write(b, 0, len);
			}
			// 刷新此缓冲的输出流
			outbuff.flush();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			// 关闭流
			close(inbuff);
			close(outbuff);
			close(out);
			close(input);
		}
	}

	/**
	 * 压缩zip格式文件
	 *
	 * @param isCover 输出文件如果存在是否覆盖输出文件。
	 * @param targetFile 输出的文件。
	 * @param sourceFiles 带压缩的文件数组。
	 * @return 如果所有文件压缩成功，则返回true；如果有任何文件未成功压缩，则返回false。
	 * @throws IOException 如果出错后无法删除目标文件或无法覆盖目标文件。
	 */
	public static boolean compressZip(boolean isCover, File targetFile, File... sourceFiles) throws IOException {
		boolean flag = false;
		if (targetFile.exists()) {
			if (isCover) {
				logger.info("删除已存在的输出文件");
				if (targetFile.delete()) {
					logger.info("删除已存在的输出文件-失败");
					return false;
				}
			} else {
				logger.info("输出文件已存在");
				return false;
			}
		}
		ZipOutputStream zipOut = null;
		BufferedOutputStream out = null;
		try {
			zipOut = new ZipOutputStream(new FileOutputStream(targetFile));
			out = new BufferedOutputStream(zipOut);
			flag = compressZip(zipOut, out, "", sourceFiles);
		} catch (IOException e) {
			targetFile.delete();
			throw new IOException(e);
		} finally {
			close(out);
			close(zipOut);
		}
		return flag;
	}

	/**
	 * 递归压缩
	 * 
	 * @param zipOut
	 * @param out
	 * @param filePath
	 * @param sourceFiles
	 * @return
	 * @throws IOException
	 */
	private static boolean compressZip(ZipOutputStream zipOut, BufferedOutputStream out, String filePath, File... sourceFiles) throws IOException {
		if (null != filePath && !"".equals(filePath)) {
			filePath += filePath.endsWith(File.separator) ? "" : File.separator;
		} else {
			filePath = "";
		}
		boolean flag = true;
		BufferedInputStream in = null;
		try {
			for (File file : sourceFiles) {
				if (null == file) {
					continue;
				}
				if (file.isDirectory()) {
					File[] fileList = file.listFiles();
					if (null == fileList) {
						return false;
					} else if (1 > fileList.length) {
						zipOut.putNextEntry(new ZipEntry(filePath + file.getName() + File.separator));
					} else {
						flag = compressZip(zipOut, out, filePath + File.separator + file.getName(), fileList) && flag; // 只要flag有一次为false，整个递归的结果都为false。
					}
				} else {
					zipOut.putNextEntry(new ZipEntry(filePath + file.getName()));
					in = new BufferedInputStream(new FileInputStream(file));
					int bytesRead;
					while (-1 != (bytesRead = in.read())) {
						out.write(bytesRead);
					}
				}
				out.flush();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			close(in);
		}
		return flag;
	}

	/**
	 * 解压zip格式文件
	 *
	 * @param originFile zip文件。
	 * @param targetDir 要解压到的目标路径。
	 * @return 如果目标文件不是zip文件则返回false。
	 * @throws IOException 如果发生I/O错误。
	 */
	public static boolean decompressZip(File originFile, String targetDir) throws IOException {
		if (FileType.ZIP != getFileType(originFile)) {
			return false;
		}
		if (!targetDir.endsWith(File.separator)) {
			targetDir += File.separator;
		}
		ZipFile zipFile = null;
		ZipEntry zipEntry = null;
		OutputStream outputStream = null;
		InputStream inputStream = null;
		try {
			zipFile = new ZipFile(originFile);
			Enumeration<ZipEntry> entry = zipFile.getEntries();
			while (entry.hasMoreElements()) {
				zipEntry = entry.nextElement();
				String fileName = zipEntry.getName();
				File outputFile = new File(targetDir + fileName);
				if (zipEntry.isDirectory()) {
					forceMkdirs(outputFile);
					continue;
				} else if (!outputFile.getParentFile().exists()) {
					forceMkdirs(outputFile.getParent());
				}
				outputStream = new FileOutputStream(outputFile);
				inputStream = zipFile.getInputStream(zipEntry);
				int len;
				byte[] buffer = new byte[8192];
				while (-1 != (len = inputStream.read(buffer))) {
					outputStream.write(buffer, 0, len);
				}
			}
			return true;
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			close(outputStream);
			close(inputStream);
			close(zipFile);
		}
		return false;
	}

	/**
	 * 获取文件真实类型
	 *
	 * @param file 要获取类型的文件。
	 * @return 文件类型枚举。
	 */
	public static FileType getFileType(File file) throws IOException {
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(file);
			byte[] head = new byte[4];
			if (-1 == inputStream.read(head)) {
				return FileType.UNKNOWN;
			}
			int headHex = 0;
			for (byte b : head) {
				headHex <<= 8;
				headHex |= b;
			}
			switch (headHex) {
			case 0x504B0304:
				return FileType.ZIP;
			default:
				return FileType.UNKNOWN;
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			close(inputStream);
		}
		return FileType.UNKNOWN;
	}

	private static void close(Closeable closeable) {
		try {
			if (closeable != null) {
				closeable.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	public static File forceMkdirs(File file) {
		if (!file.exists()) {
			file.mkdirs();
		} else if (!file.isDirectory()) {
			file.delete();
			file.mkdirs();
		}
		return file;
	}

	public static File forceMkdirs(String pathName) {
		return forceMkdirs(new File(pathName));
	}

	public static File forceMkdirs(File parent, String child) {
		return forceMkdirs(new File(parent, child));
	}

	public static File forceMkdirs(String parent, String child) {
		return forceMkdirs(new File(parent, child));
	}

	public static void main(String[] args) throws IOException {
		// String targetDir = "C:\\Users\\User\\Desktop\\";
		// File originFile = new File(targetDir,
		// "000001806252569_20180704_20180705093600_1_1.zip");
		// decompressZip(originFile, targetDir);
		File targetFile = new File("D:\\program\\360cse\\360Chrome\\test.zip");
		File sourceFiles = new File("D:\\temple\\sysMenu-add.html");
		boolean flag = compressZip(false, targetFile, sourceFiles);
		System.out.println(flag);
	}
}
