package com.zhd.exploit.utils.security;

public class RC4 {
	
	private byte[] engineState = null;
	private int x = 0;
	private int y = 0;
	private byte[] workingKey = null;

	public RC4(String key) {
		this.workingKey = key.getBytes();
	}

	private void processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) {
		if (inOff + len > in.length) {
			throw new RuntimeException("input buffer too short");
		}

		if (outOff + len > out.length) {
			throw new RuntimeException("output buffer too short");
		}

		for (int i = 0; i < len; i++) {
			this.x = (this.x + 1 & 0xFF);
			this.y = (this.engineState[this.x] + this.y & 0xFF);

			byte tmp = this.engineState[this.x];
			this.engineState[this.x] = this.engineState[this.y];
			this.engineState[this.y] = tmp;

			out[(i + outOff)] = ((byte) (in[(i + inOff)]
					^ this.engineState[(this.engineState[this.x] + this.engineState[this.y] & 0xFF)]));
		}
	}

	private void setKey(byte[] keyBytes) {
		this.x = 0;
		this.y = 0;

		if (this.engineState == null) {
			this.engineState = new byte[256];
		}

		for (int i = 0; i < 256; i++) {
			this.engineState[i] = ((byte) i);
		}

		int i1 = 0;
		int i2 = 0;

		for (int i = 0; i < 256; i++) {
			i2 = (keyBytes[i1] & 0xFF) + this.engineState[i] + i2 & 0xFF;

			byte tmp = this.engineState[i];
			this.engineState[i] = this.engineState[i2];
			this.engineState[i2] = tmp;
			i1 = (i1 + 1) % keyBytes.length;
		}
	}

	private void reset() {
		setKey(this.workingKey);
	}

	public byte[] encrypt(byte[] data) {
		reset();

		byte[] out = new byte[data.length];
		processBytes(data, 0, data.length, out, 0);

		return out;
	}

	public byte[] decrypt(byte[] data) {
		reset();

		byte[] out = new byte[data.length];
		processBytes(data, 0, data.length, out, 0);

		return out;
	}
}